---
author: "Pahlevi Fikri Auliya"
format:
  revealjs:
    theme: custom.scss
    incremental: false
    slide-number: true
    embed-resources: false
    transition: slide
    background-transition: fade
---

# Design Patterns in the Age of AI

Pahlevi Fikri Auliya

# Goals

---

<iframe width="100%" height="100%" src="animations/tree.html" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

# Target Audience

- Junior-Senior Software Engineers

# Non-Target Audience

- Those who are just learning to code


# Realities Today

- Most code can be generated by AI
- We all code using AI, don't we?
- AI is still poor at making architecture decisions
- We still need to guide where AI goes


# We Are All Becoming Architects


# Iterator

---

<iframe width="100%" height="100%" src="examples/iterator/00-animation.html" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

---

## Array Iterator

:::: {.columns}

::: {.column width="50%"}

```{.python code-line-numbers="|18-21|23,24"}
class BookShelf:
    def __init__(self):
        self.books = []
    
    def add_book(self, book):
        self.books.append(book)
    
    def get_books(self):
        return self.books


# Client code has to know internal structure
shelf = BookShelf()
shelf.add_book("Design Patterns")
shelf.add_book("Clean Code")
shelf.add_book("Refactoring")

# Direct access to internal list
books = shelf.get_books()
for i in range(len(books)):
    print(f"Book {i + 1}: {books[i]}")

# Client can modify internal state
books.clear()  # This breaks encapsulation!
```
:::

::: {.column width="50%"}

```{.python code-line-numbers="|11-14|32-36"}
class BookShelf:
    def __init__(self):
        self._books = []
    
    def add_book(self, book):
        self._books.append(book)
    
    def __iter__(self):
        return BookIterator(self._books)

class BookIterator:
    def __init__(self, books):
        self._books = books
        self._index = 0
    
    def __iter__(self):
        return self
    
    def __next__(self):
        if self._index < len(self._books):
            book = self._books[self._index]
            self._index += 1
            return book
        raise StopIteration

# Client code doesn't need to know internal structure
shelf = BookShelf()
shelf.add_book("Design Patterns")
shelf.add_book("Clean Code")
shelf.add_book("Refactoring")

# Clean iteration without exposing internals
for book in shelf:
    print(f"Book: {book}")

# Can't modify internal state - better encapsulation!
```
:::
::::

## Tree Iterator

:::: {.columns}

::: {.column width="50%"}
```{.python code-line-numbers="|27-29"}
class TreeNode:
    def __init__(self, value):
        self.value = value
        self.children = []
    
    def add_child(self, child):
        self.children.append(child)
    
    def traverse(self):
        """Tight coupling - traversal logic mixed with tree structure"""
        result = []
        
        def _traverse_recursive(node):
            result.append(node.value)
            for child in node.children:
                _traverse_recursive(child)
        
        _traverse_recursive(self)
        return result

# Usage
root = TreeNode("A")
root.add_child(TreeNode("B"))
root.add_child(TreeNode("C"))
root.children[0].add_child(TreeNode("D"))

# Only one way to traverse - tightly coupled
values = root.traverse()
print(values)  # ['A', 'B', 'D', 'C']
```
:::

::: {.column width="50%"}
```{.python code-line-numbers="|37-39|41-44"}
class TreeNode:
    def __init__(self, value):
        self.value = value
        self.children = []
    
    def add_child(self, child):
        self.children.append(child)
    
    def __iter__(self):
        """Returns an iterator - separation of concerns"""
        return TreeIterator(self)

class TreeIterator:
    def __init__(self, root):
        self.stack = [root]
    
    def __iter__(self):
        return self
    
    def __next__(self):
        if not self.stack:
            raise StopIteration
        
        current = self.stack.pop()
        # Add children in reverse order for left-to-right traversal
        for child in reversed(current.children):
            self.stack.append(child)
        
        return current.value

# Usage
root = TreeNode("A")
root.add_child(TreeNode("B"))
root.add_child(TreeNode("C"))
root.children[0].add_child(TreeNode("D"))

# Clean iteration interface
for value in root:
    print(value)  # A, B, D, C

# Can also manually control iteration
iterator = iter(root)
print(next(iterator))  # A
print(next(iterator))  # B
```
:::
::::

---

## Directory Iterator

:::: {.columns}

::: {.column width="50%"}

```{.python code-line-numbers="|27-30"}
import os

class Directory:
    def __init__(self, path):
        self.path = path
    
    def get_all_files(self):
        """Tight coupling - loads everything into memory at once"""
        all_files = []
        
        def _collect_files(current_path):
            try:
                for item in os.listdir(current_path):
                    item_path = os.path.join(current_path, item)
                    if os.path.isfile(item_path):
                        all_files.append(item_path)
                    elif os.path.isdir(item_path):
                        _collect_files(item_path)  # Recursive
            except PermissionError:
                pass  # Skip inaccessible directories
        
        _collect_files(self.path)
        return all_files

# Usage
directory = Directory("/some/path")
files = directory.get_all_files()  # Loads ALL files at once!

for file_path in files:
    print(file_path)
```
:::

::: {.column width="50%"}
```{.python code-line-numbers="|38-43|45-48"}
import os

class Directory:
    def __init__(self, path):
        self.path = path
    
    def __iter__(self):
        return DirectoryIterator(self.path)

class DirectoryIterator:
    def __init__(self, root_path):
        self.stack = [root_path]
    
    def __iter__(self):
        return self
    
    def __next__(self):
        while self.stack:
            current_path = self.stack.pop()
            
            if os.path.isfile(current_path):
                return current_path
            
            elif os.path.isdir(current_path):
                try:
                    items = os.listdir(current_path)
                    for item in reversed(items):
                        item_path = os.path.join(current_path, item)
                        self.stack.append(item_path)
                except PermissionError:
                    continue
        
        raise StopIteration

# Usage
directory = Directory("/some/path")

# Lazy iteration - files yielded one by one
for file_path in directory:
    print(file_path)
    # Can break early without processing remaining files
    if file_path.endswith('.txt'):
        break

# Manual control
iterator = iter(directory)
first_file = next(iterator)
second_file = next(iterator)
```
:::
::::

---

## `yield`

```{.python code-line-numbers="|3,5,7"}
def simple_counter():
    print("Starting...")
    yield 1
    print("After first yield")
    yield 2
    print("After second yield")
    yield 3
    print("Done!")

# Usage
counter = simple_counter()  # Creates generator, doesn't run yet!
print("Generator created")

print(next(counter))  # Starting... 1
print(next(counter))  # After first yield 2
print(next(counter))  # After second yield 3
# print(next(counter))  # Done! StopIteration
```

---

## `yield` vs `return`

```{.python code-line-numbers="|3-5,9-11"}
# With return - function ends
def with_return():
    return 1
    return 2  # Never reached!
    return 3  # Never reached!

# With yield - function pauses
def with_yield():
    yield 1   # Pause here, remember state
    yield 2   # Resume here next time
    yield 3   # Resume here next time

print(list(with_yield()))  # [1, 2, 3]
```

---

## Lazy Generator

```{.python code-line-numbers="|3-5|11-14"}
def count_up_to(max_num):
    count = 1
    while count <= max_num:
        yield count
        count += 1

# Usage
for num in count_up_to(5):
    print(num)  # 1, 2, 3, 4, 5

# Memory efficient - generates one number at a time!
numbers = count_up_to(1000000)  # Doesn't create million numbers in memory
print(next(numbers))  # 1
print(next(numbers))  # 2
```

---

## Directory Traversal with `yield`

```{.python code-line-numbers="|11|22-26"}
import os

def iterate_files(path):
    """Generator function using yield"""
    stack = [path]
    
    while stack:
        current_path = stack.pop()
        
        if os.path.isfile(current_path):
            yield current_path  # Pause here, return file path
        
        elif os.path.isdir(current_path):
            try:
                items = os.listdir(current_path)
                for item in reversed(items):
                    item_path = os.path.join(current_path, item)
                    stack.append(item_path)
            except PermissionError:
                continue

# Usage - same as Iterator pattern but much simpler!
for file_path in iterate_files("/some/path"):
    print(file_path)
    if file_path.endswith('.txt'):
        break  # Can still break early!
```

# Observer

## React `useState`

# State Machine

## 

# DSL